"""
This class contains the methods that simulate either one building or all buildings
"""

from iso_simulator.data_source.datasource import DataSource
from iso_simulator.data_source.datasource_csv import DataSourceCSV
from iso_simulator.building_simulator.simulator import BuildingSimulator
from iso_simulator.building_simulator.all_buildings import SimulateAllBuilding
from iso_simulator.model.results import Result
from iso_simulator.model.ResultOutput import ResultOutput
from iso_simulator.model.generate_data import GenerateData
import time
import timeit
import multiprocessing as mp
import concurrent.futures
import threading
import logging
import inspect
import multiprocessing

log_file = 'simulation_log.txt'
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s', filename=log_file,
                    filemode='a')


class DIBS:
    def __init__(self, datasource: DataSourceCSV):
        """
        This constructor to initialize an instance of the DIBS class
        Args:
            datasource: object which can deal with several data format (csv file, JSON, database, etc...)
        """
        self.datasource = datasource
        self.callback = None

    def set_callback(self, callback_function):
        self.callback = callback_function

    def set_data_source(self, datasource: DataSource):
        self.datasource = datasource

    def calculate_all_buildings_results(self, generate_data: GenerateData, weather_period: str):
        """
        This method simulates all the building generated by the object generate_data. The logic of the simulation
        is in the method calculate_result_of_all_buildings below implemented

        Args:
            generate_data: retrieves all buildings and gwp_PE_Factors
            weather_period: period to simulate

        Returns:
            Results of all simulated buildings

        """

        results_of_all_buildings = []
        results_for_all_hours = []

        begin_simulation_time = time.time()
        for index, building in enumerate(generate_data.all_buildings):
            result_for_all_hours, result_of_a_building = self.calculate_result_of_all_buildings(generate_data,
                                                                                                weather_period, index)
            results_of_all_buildings.append(result_of_a_building)
            results_for_all_hours.append(result_for_all_hours)
        self.datasource.build_all_results_of_all_buildings(results_of_all_buildings)
        end_simulation_time = time.time()
        print(
            f'Simulation time of all buildings with saving any results is : {end_simulation_time - begin_simulation_time}s')
        begin_saving_time = time.time()
        for index, result in enumerate(results_for_all_hours):
            self.datasource.result_of_all_hours_to_csv(result, generate_data.all_buildings[index])
        end_saving_time = time.time()
        print(
            f'Saving time of all hourly results of all buildings is : {end_saving_time - begin_saving_time}s')

    def calculate_result_of_one_building(self, building_id: str, weather_period: str):
        """
        This method simulates the building with the given building_id as parameter
        Args:
            generate_data: retrieves all buildings and gwp_PE_Factors
            building_id: building to simulate
            weather_period: period to simulate

        Returns:

        """
        time_begin = time.time()

        simulator = BuildingSimulator(self.datasource, building_id, weather_period, 'din18599', 'mid', 'sia2024')

        t_set_heating_temp = simulator.building_object.t_set_heating

        result = Result()

        simulator.check_energy_area_and_heating()

        gain_person_and_typ_norm, appliance_gains = simulator.datasourcecsv.get_gains(simulator.building_object.hk_geb,
                                                                                      simulator.building_object.uk_geb,
                                                                                      simulator.profile_from_norm,
                                                                                      simulator.gains_from_group_values)

        gain_per_person, typ_norm = gain_person_and_typ_norm

        usage_start, usage_end = simulator.get_usage_start_and_end()

        occupancy_schedule, schedule_name, occupancy_full_usage_hours = simulator.get_schedule()

        tek_dhw, tek_name = simulator.get_tek()

        tek_dhw_per_occupancy_full_usage_hour = tek_dhw / occupancy_full_usage_hours

        t_m_prev = simulator.building_object.t_start

        for hour in range(8760):
            simulator.building_object.t_set_heating = t_set_heating_temp
            t_out = simulator.extract_outdoor_temperature(hour)

            altitude, azimuth = simulator.calc_altitude_and_azimuth(hour)

            simulator.building_object.h_ve_adj = simulator.building_object.calc_h_ve_adj(hour, t_out, usage_start,
                                                                                         usage_end)

            t_air = simulator.set_t_air_based_on_hour(hour)

            simulator.calc_solar_gains_for_all_windows(altitude, azimuth, t_air, hour)
            simulator.calc_illuminance_for_all_windows(altitude, azimuth, hour)

            occupancy_percent = occupancy_schedule[hour].People
            occupancy = simulator.calc_occupancy(occupancy_schedule, hour)

            simulator.building_object.solve_building_lighting(simulator.calc_sum_illuminance_all_windows(),
                                                              occupancy_percent)
            internal_gains = simulator.calc_gains_from_occupancy_and_appliances(occupancy_schedule, occupancy,
                                                                                gain_per_person, appliance_gains, hour)

            """
            Calculate appliance_gains as part of the internal_gains
            """
            appliance_gains_demand = simulator.calc_appliance_gains_demand(occupancy_schedule, appliance_gains, hour)
            """
            Appliance_gains equal the electric energy that appliances use, except for negative appliance_gains of refrigerated counters in trade buildings for food!
            The assumption is: negative appliance_gains come from referigerated counters with heat pumps for which we assume a COP = 2.
            """
            appliance_gains_demand_elt = simulator.get_appliance_gains_elt_demand(occupancy_schedule, appliance_gains,
                                                                                  hour)
            """
            Calculate energy demand for the time step
            """
            simulator.calc_energy_demand_for_time_step(internal_gains, t_out, t_m_prev)
            """
            Calculate hot water usage of the building for the time step with (BuildingInstance.heating_energy
             / BuildingInstance.heating_demand) represents the Efficiency of the heat generation in the building
            """

            hot_water_demand, hot_water_energy, hot_water_sys_electricity, hot_water_sys_fossils = simulator.calc_hot_water_usage(
                occupancy_schedule, tek_dhw_per_occupancy_full_usage_hour, hour)

            """
            Set the previous temperature for the next time step
            """
            t_m_prev = simulator.building_object.t_m_next
            """
            Append results to the created lists 
            """
            result.append_results(simulator.building_object, simulator.all_windows, hot_water_demand, hot_water_energy,
                                  hot_water_sys_electricity, hot_water_sys_fossils, t_out, internal_gains,
                                  appliance_gains_demand, appliance_gains_demand_elt,
                                  simulator.calc_sum_solar_gains_all_windows(), hour)

        """
        Some calculations used for the console prints
        """
        sum_of_all_results = result.calc_sum_of_results()
        """
        the fuel-related final energy sums, f.i. HeatingEnergy_sum, are calculated based upon the superior heating value
        Hs since the corresponding expenditure factors from TEK 9.24 represent the ration of Hs-related final energy to 
        useful energy.
         --- Calculation  related to HEATING and Hotwater energy ---
        """
        fuel_type = simulator.choose_the_fuel_type()

        """
        Heating:
            - GHG-Factor Heating
            - PE-Factor Heating
            - Umrechnungsfaktor von Brennwert (Hs) zu Heizwert (Hi) einlesen
        """
        f_ghg, f_pe, f_hs_hi, fuel_type = simulator.get_ghg_pe_conversion_factors(fuel_type)

        heating_sys_electricity_hi_sum, heating_sys_carbon_sum, heating_sys_pe_sum, heating_sys_fossils_hi_sum = simulator.check_heating_sys_electricity_sum(
            sum_of_all_results, f_hs_hi, f_ghg, f_pe)

        heating_sys_hi_sum = simulator.sys_electricity_folssils_sum(
            heating_sys_electricity_hi_sum, heating_sys_fossils_hi_sum)

        heating_fuel_type = fuel_type
        heating_f_ghg = f_ghg
        heating_f_pe = f_pe
        heating_f_hs_hi = f_hs_hi

        """
        HOT WATER
        Assumption: Central DHW-Systems use the same Fuel_type as Heating-Systems, only decentral DHW-Systems might have
        another Fuel-Type.
        """
        fuel_type = simulator.check_if_central_dhw_use_same_fuel_type_as_heating_system(heating_fuel_type)

        f_ghg, f_pe, f_hs_hi, fuel_type = simulator.get_ghg_pe_conversion_factors(fuel_type)

        hot_water_sys_electricity_hi_sum, hot_water_sys_pe_sum, hot_water_sys_carbon_sum, hot_water_sys_fossils_hi_sum = simulator.check_hotwater_sys_electricity_sum(
            sum_of_all_results, f_hs_hi, f_ghg, f_pe)

        hot_water_energy_hi_sum = simulator.sys_electricity_folssils_sum(hot_water_sys_electricity_hi_sum,
                                                                         hot_water_sys_fossils_hi_sum)

        hot_water_fuel_type = fuel_type
        hot_water_f_ghg = f_ghg
        hot_water_f_pe = f_pe
        hot_water_f_hs_hi = f_hs_hi

        """
        Cooling energy
        """
        fuel_type = simulator.choose_cooling_energy_fuel_type()

        f_ghg, f_pe, f_hs_hi, fuel_type = simulator.get_ghg_pe_conversion_factors(fuel_type)

        cooling_sys_electricity_hi_sum, cooling_sys_carbon_sum, cooling_sys_pe_sum, cooling_sys_fossils_hi_sum = simulator.check_cooling_system_elctricity_sum(
            sum_of_all_results, f_hs_hi, f_ghg, f_pe)

        cooling_sys_hi_sum = simulator.cooling_sys_hi_sum(cooling_sys_electricity_hi_sum, cooling_sys_fossils_hi_sum)

        cooling_fuel_type = fuel_type
        cooling_f_ghg = f_ghg
        cooling_f_pe = f_pe
        cooling_f_hs_hi = f_hs_hi

        """
        remaining Electric energy (LightingDemand_sum + Appliance_gains_elt_demand_sum)
        Lighting
        electrical energy for lighting
        """
        fuel_type = 'Electricity grid mix'
        f_ghg, f_pe, f_hs_hi, fuel_type = simulator.get_ghg_pe_conversion_factors(fuel_type)

        lighting_demand_hi_sum = sum_of_all_results.LightingDemand_sum / f_hs_hi  # for kWhHi Final Energy Demand
        lighting_demand_carbon_sum = (lighting_demand_hi_sum * f_ghg) / 1000  # for kg CO2eq
        lighting_demand_pe_sum = lighting_demand_hi_sum * f_pe  # for kWhHs Primary Energy Demand

        appliance_gains_demand_hi_sum = sum_of_all_results.Appliance_gains_elt_demand_sum / f_hs_hi  # for kWhHi Final Energy Demand
        appliance_gains_demand_pe_sum = appliance_gains_demand_hi_sum * f_pe  # for kWhHs Primary Energy Demand
        appliance_gains_demand_carbon_sum = (appliance_gains_demand_hi_sum * f_ghg) / 1000  # for kg CO2eq

        light_appl_fuel_type = fuel_type
        light_appl_f_ghg = f_ghg
        light_appl_f_pe = f_pe
        light_appl_f_hs_hi = f_hs_hi

        """
        Calculation of Carbon Emission related to the entire energy consumption (Heating_Sys_Carbon_sum + 
        Cooling_Sys_Carbon_sum + LightingDemand_Carbon_sum + Appliance_gains_demand_Carbon_sum)
        """
        carbon_sum = heating_sys_carbon_sum + cooling_sys_carbon_sum + lighting_demand_carbon_sum + appliance_gains_demand_carbon_sum + hot_water_sys_carbon_sum

        """
        Calculation of Primary Energy Demand related to the entire energy consumption (Heating_Sys_PE_sum +
         Cooling_Sys_PE_sum + LightingDemand_PE_sum + Appliance_gains_demand_PE_sum + HotWater_Sys_PE_sum)
        """
        pe_sum = heating_sys_pe_sum + cooling_sys_pe_sum + lighting_demand_pe_sum + appliance_gains_demand_pe_sum + hot_water_sys_pe_sum

        """
        Calculation of Final Energy Hi Demand related to the entire energy consumption
        """
        fe_hi_sum = heating_sys_hi_sum + cooling_sys_hi_sum + lighting_demand_hi_sum + appliance_gains_demand_hi_sum + hot_water_energy_hi_sum

        """
        Build Results of a building
        """
        result_output = ResultOutput(simulator.building_object, sum_of_all_results, heating_sys_hi_sum,
                                     heating_sys_electricity_hi_sum, heating_sys_fossils_hi_sum, heating_sys_carbon_sum,
                                     heating_sys_pe_sum, cooling_sys_carbon_sum, cooling_sys_pe_sum,
                                     hot_water_energy_hi_sum, heating_fuel_type, heating_f_ghg, heating_f_pe,
                                     heating_f_hs_hi, hot_water_fuel_type, hot_water_f_ghg, hot_water_f_pe,
                                     hot_water_f_hs_hi, cooling_fuel_type, cooling_f_ghg, cooling_f_pe, cooling_f_hs_hi,
                                     light_appl_fuel_type, light_appl_f_ghg, light_appl_f_pe, light_appl_f_hs_hi,
                                     hot_water_sys_carbon_sum, hot_water_sys_pe_sum, lighting_demand_carbon_sum,
                                     lighting_demand_pe_sum, appliance_gains_demand_carbon_sum,
                                     appliance_gains_demand_pe_sum, carbon_sum, pe_sum, fe_hi_sum, schedule_name,
                                     typ_norm, simulator.epw_object.file_name)

        result_data_frame = simulator.datasourcecsv.result_to_pandas_dataframe(result_output)
        building_name_file = simulator.building_object.scr_gebaeude_id + '.xlsx'
        result_data_frame.to_excel(f'results_after_calculations/{building_name_file}')

        simulation_time = time.time() - time_begin
        print(f'Simulation time without saving time of all hours is: {simulation_time}s')

        begin_time_csv = time.time()
        simulator.datasourcecsv.result_of_all_hours_to_csv(result,
                                                           simulator.building_object)

        dt_csv = time.time() - begin_time_csv
        print(f'Time to save results of all hours in an CSV file: {dt_csv}s')
        print(
            f'Complete time to simulate, save results of all hours in an CSV file and save result of the building in an Excel file is: {simulation_time + dt_csv}s')

    def calculate_result_of_all_buildings(self, generate_data: GenerateData, weather_period: str, index: int) -> tuple[
        Result, ResultOutput]:
        begin_time = time.time()

        simulator = SimulateAllBuilding(self.datasource, generate_data.all_buildings, generate_data.gwp_pe_factors,
                                        index,
                                        weather_period, 'din18599', 'mid', 'sia2024')

        t_set_heating_temp = generate_data.all_buildings[index].t_set_heating

        result = Result()

        simulator.check_energy_area_and_heating()

        gain_person_and_typ_norm, appliance_gains = simulator.datasourcecsv.get_gains(simulator.building_object.hk_geb,
                                                                                      simulator.building_object.uk_geb,
                                                                                      simulator.profile_from_norm,
                                                                                      simulator.gains_from_group_values)

        gain_per_person, typ_norm = gain_person_and_typ_norm

        usage_start, usage_end = simulator.get_usage_start_and_end()

        occupancy_schedule, schedule_name, occupancy_full_usage_hours = simulator.get_schedule()

        tek_dhw, tek_name = simulator.get_tek()

        tek_dhw_per_occupancy_full_usage_hour = tek_dhw / occupancy_full_usage_hours

        t_m_prev = simulator.building_object.t_start

        for hour in range(8760):
            simulator.building_object.t_set_heating = t_set_heating_temp
            t_out = simulator.extract_outdoor_temperature(hour)

            altitude, azimuth = simulator.calc_altitude_and_azimuth(hour)

            simulator.building_object.h_ve_adj = simulator.building_object.calc_h_ve_adj(hour, t_out, usage_start,
                                                                                         usage_end)

            t_air = simulator.set_t_air_based_on_hour(hour)

            simulator.calc_solar_gains_for_all_windows(altitude, azimuth, t_air, hour)
            simulator.calc_illuminance_for_all_windows(altitude, azimuth, hour)

            occupancy_percent = occupancy_schedule[hour].People
            occupancy = simulator.calc_occupancy(occupancy_schedule, hour)

            simulator.building_object.solve_building_lighting(simulator.calc_sum_illuminance_all_windows(),
                                                              occupancy_percent)
            internal_gains = simulator.calc_gains_from_occupancy_and_appliances(occupancy_schedule, occupancy,
                                                                                gain_per_person, appliance_gains, hour)

            """
            Calculate appliance_gains as part of the internal_gains
            """
            appliance_gains_demand = simulator.calc_appliance_gains_demand(occupancy_schedule, appliance_gains, hour)
            """
            Appliance_gains equal the electric energy that appliances use, except for negative appliance_gains of refrigerated counters in trade buildings for food!
            The assumption is: negative appliance_gains come from referigerated counters with heat pumps for which we assume a COP = 2.
            """
            appliance_gains_demand_elt = simulator.get_appliance_gains_elt_demand(occupancy_schedule, appliance_gains,
                                                                                  hour)
            """
            Calculate energy demand for the time step
            """
            simulator.calc_energy_demand_for_time_step(internal_gains, t_out, t_m_prev)
            """
            Calculate hot water usage of the building for the time step with (BuildingInstance.heating_energy
             / BuildingInstance.heating_demand) represents the Efficiency of the heat generation in the building
            """

            hot_water_demand, hot_water_energy, hot_water_sys_electricity, hot_water_sys_fossils = simulator.calc_hot_water_usage(
                occupancy_schedule, tek_dhw_per_occupancy_full_usage_hour, hour)

            """
            Set the previous temperature for the next time step
            """
            t_m_prev = simulator.building_object.t_m_next
            """
            Append results to the created lists 
            """
            result.append_results(simulator.building_object, simulator.all_windows, hot_water_demand, hot_water_energy,
                                  hot_water_sys_electricity, hot_water_sys_fossils, t_out, internal_gains,
                                  appliance_gains_demand, appliance_gains_demand_elt,
                                  simulator.calc_sum_solar_gains_all_windows(), hour)

        """
        Some calculations used for the console prints
        """
        sum_of_all_results = result.calc_sum_of_results()
        """
        the fuel-related final energy sums, f.i. HeatingEnergy_sum, are calculated based upon the superior heating value
        Hs since the corresponding expenditure factors from TEK 9.24 represent the ration of Hs-related final energy to 
        useful energy.
         --- Calculation  related to HEATING and Hotwater energy ---
        """
        fuel_type = simulator.choose_the_fuel_type()

        """
        Heating:
            - GHG-Factor Heating
            - PE-Factor Heating
            - Umrechnungsfaktor von Brennwert (Hs) zu Heizwert (Hi) einlesen
        """
        f_ghg, f_pe, f_hs_hi, fuel_type = simulator.get_ghg_pe_conversion_factors(fuel_type)

        heating_sys_electricity_hi_sum, heating_sys_carbon_sum, heating_sys_pe_sum, heating_sys_fossils_hi_sum = simulator.check_heating_sys_electricity_sum(
            sum_of_all_results, f_hs_hi, f_ghg, f_pe)

        heating_sys_hi_sum = simulator.sys_electricity_folssils_sum(
            heating_sys_electricity_hi_sum, heating_sys_fossils_hi_sum)

        heating_fuel_type = fuel_type
        heating_f_ghg = f_ghg
        heating_f_pe = f_pe
        heating_f_hs_hi = f_hs_hi

        """
        HOT WATER
        Assumption: Central DHW-Systems use the same Fuel_type as Heating-Systems, only decentral DHW-Systems might have
        another Fuel-Type.
        """
        fuel_type = simulator.check_if_central_dhw_use_same_fuel_type_as_heating_system(heating_fuel_type)

        f_ghg, f_pe, f_hs_hi, fuel_type = simulator.get_ghg_pe_conversion_factors(fuel_type)

        hot_water_sys_electricity_hi_sum, hot_water_sys_pe_sum, hot_water_sys_carbon_sum, hot_water_sys_fossils_hi_sum = simulator.check_hotwater_sys_electricity_sum(
            sum_of_all_results, f_hs_hi, f_ghg, f_pe)

        hot_water_energy_hi_sum = simulator.sys_electricity_folssils_sum(hot_water_sys_electricity_hi_sum,
                                                                         hot_water_sys_fossils_hi_sum)

        hot_water_fuel_type = fuel_type
        hot_water_f_ghg = f_ghg
        hot_water_f_pe = f_pe
        hot_water_f_hs_hi = f_hs_hi

        """
        Cooling energy
        """
        fuel_type = simulator.choose_cooling_energy_fuel_type()

        f_ghg, f_pe, f_hs_hi, fuel_type = simulator.get_ghg_pe_conversion_factors(fuel_type)

        cooling_sys_electricity_hi_sum, cooling_sys_carbon_sum, cooling_sys_pe_sum, cooling_sys_fossils_hi_sum = simulator.check_cooling_system_elctricity_sum(
            sum_of_all_results, f_hs_hi, f_ghg, f_pe)

        cooling_sys_hi_sum = simulator.cooling_sys_hi_sum(cooling_sys_electricity_hi_sum, cooling_sys_fossils_hi_sum)

        cooling_fuel_type = fuel_type
        cooling_f_ghg = f_ghg
        cooling_f_pe = f_pe
        cooling_f_hs_hi = f_hs_hi

        """
        remaining Electric energy (LightingDemand_sum + Appliance_gains_elt_demand_sum)
        Lighting
        electrical energy for lighting
        """
        fuel_type = 'Electricity grid mix'
        f_ghg, f_pe, f_hs_hi, fuel_type = simulator.get_ghg_pe_conversion_factors(fuel_type)

        lighting_demand_hi_sum = sum_of_all_results.LightingDemand_sum / f_hs_hi  # for kWhHi Final Energy Demand
        lighting_demand_carbon_sum = (lighting_demand_hi_sum * f_ghg) / 1000  # for kg CO2eq
        lighting_demand_pe_sum = lighting_demand_hi_sum * f_pe  # for kWhHs Primary Energy Demand

        appliance_gains_demand_hi_sum = sum_of_all_results.Appliance_gains_elt_demand_sum / f_hs_hi  # for kWhHi Final Energy Demand
        appliance_gains_demand_pe_sum = appliance_gains_demand_hi_sum * f_pe  # for kWhHs Primary Energy Demand
        appliance_gains_demand_carbon_sum = (appliance_gains_demand_hi_sum * f_ghg) / 1000  # for kg CO2eq

        light_appl_fuel_type = fuel_type
        light_appl_f_ghg = f_ghg
        light_appl_f_pe = f_pe
        light_appl_f_hs_hi = f_hs_hi

        """
        Calculation of Carbon Emission related to the entire energy consumption (Heating_Sys_Carbon_sum + 
        Cooling_Sys_Carbon_sum + LightingDemand_Carbon_sum + Appliance_gains_demand_Carbon_sum)
        """
        carbon_sum = heating_sys_carbon_sum + cooling_sys_carbon_sum + lighting_demand_carbon_sum + appliance_gains_demand_carbon_sum + hot_water_sys_carbon_sum

        """
        Calculation of Primary Energy Demand related to the entire energy consumption (Heating_Sys_PE_sum +
         Cooling_Sys_PE_sum + LightingDemand_PE_sum + Appliance_gains_demand_PE_sum + HotWater_Sys_PE_sum)
        """
        pe_sum = heating_sys_pe_sum + cooling_sys_pe_sum + lighting_demand_pe_sum + appliance_gains_demand_pe_sum + hot_water_sys_pe_sum

        """
        Calculation of Final Energy Hi Demand related to the entire energy consumption
        """
        fe_hi_sum = heating_sys_hi_sum + cooling_sys_hi_sum + lighting_demand_hi_sum + appliance_gains_demand_hi_sum + hot_water_energy_hi_sum

        """
        Build Results of a building
        """
        result_output = ResultOutput(simulator.building_object, sum_of_all_results, heating_sys_hi_sum,
                                     heating_sys_electricity_hi_sum, heating_sys_fossils_hi_sum, heating_sys_carbon_sum,
                                     heating_sys_pe_sum, cooling_sys_carbon_sum, cooling_sys_pe_sum,
                                     hot_water_energy_hi_sum, heating_fuel_type, heating_f_ghg, heating_f_pe,
                                     heating_f_hs_hi, hot_water_fuel_type, hot_water_f_ghg, hot_water_f_pe,
                                     hot_water_f_hs_hi, cooling_fuel_type, cooling_f_ghg, cooling_f_pe, cooling_f_hs_hi,
                                     light_appl_fuel_type, light_appl_f_ghg, light_appl_f_pe, light_appl_f_hs_hi,
                                     hot_water_sys_carbon_sum, hot_water_sys_pe_sum, lighting_demand_carbon_sum,
                                     lighting_demand_pe_sum, appliance_gains_demand_carbon_sum,
                                     appliance_gains_demand_pe_sum, carbon_sum, pe_sum, fe_hi_sum, schedule_name,
                                     typ_norm, simulator.epw_object.file_name)

        # end = time.time()
        # lang = end - begin_time
        # print(f'Time to simulate building {simulator.building_object.scr_gebaeude_id} is : {lang}s')
        return result, result_output

    def parallel_mp_calculation(self, generate_data: GenerateData, weather_period: str):

        processes = []
        buildings = generate_data.all_buildings

        begin_simulation_time = time.time()

        for index, building in enumerate(buildings):
            args = [generate_data, weather_period, index]
            process = mp.Process(target=self.calculate_result_of_all_buildings, args=args)
            processes.append(process)
            process.start()

        for process in processes:
            process.join()

        end_simulation_time = time.time()

        print(
            f'Time is : {end_simulation_time - begin_simulation_time}s')

    def parallel_thread_max_concurrent(self, generate_data: GenerateData, weather_period, max_concurrent: int):
        semaphore = concurrent.futures.ThreadPoolExecutor(max_concurrent)
        buildings = generate_data.all_buildings
        begin = time.time()
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = []

            for index, building in enumerate(buildings):
                args = [generate_data, weather_period, index]
                future = semaphore.submit(self.calculate_result_of_all_buildings, *args)
                futures.append(future)
            concurrent.futures.wait(futures)
        end = time.time()
        print(f'Simulation time is : {end - begin}')

    def parallel_thread_calculation(self, generate_data: GenerateData, weather_period):
        current_function_name = inspect.stack()[0][3]
        buildings = generate_data.all_buildings
        begin = time.time()
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = [
                executor.submit(self.calculate_result_of_all_buildings, generate_data, weather_period, index,
                                ) for index, building in enumerate(buildings)]
            results = [future.result() for future in concurrent.futures.as_completed(futures)]
        end = time.time()
        logging.info(f'-----------Simulation using the method {current_function_name}-----------')
        logging.info(f"Parallel Process Calculation time is {end - begin:.2f} Seconds.")

        unpack_time, result, result_output = self.unpack_results(results)

        begin_final_result = time.time()
        self.datasource.build_all_results_of_all_buildings(result_output)
        end_final_result = time.time()

        saving_time = self.save_results_of_all_buildings_in_csv_parallel_using_thread_executor(
            buildings, result)

        logging.info(
            f"Time of saving the final result of {len(buildings)} buildings is {end_final_result - begin_final_result:.2f} Seconds.")

        logging.info(
            f"Time of saving hours results of {len(buildings)} buildings is {saving_time:.2f} Seconds.")
        logging.warning(
            f"Total time to simulate {len(buildings)} buildings and save hourly and final results is {end - begin + saving_time + unpack_time:.2f} Seconds.")
        logging.info(f'-----------------------------End simulation using process----------------------------')

    def parallel_process_calculation(self, generate_data: GenerateData, weather_period):
        logging.info("-" * 90)
        logging.info("-" * 90)
        current_function_name = inspect.stack()[0][3]
        buildings = generate_data.all_buildings
        simulation_time, results = self.simulate_all_buildings_parallel_using_process_executor(
            buildings, generate_data, weather_period)

        logging.info(f'-----------Simulation using the method {current_function_name}-----------')
        logging.info(f"Parallel Process Calculation time is {simulation_time:.2f} Seconds.")

        unpack_time, result, result_output = self.unpack_results(results)

        begin_final_result = time.time()
        self.datasource.build_all_results_of_all_buildings(result_output)
        end_final_result = time.time()
        logging.info(
            f"Time of saving the final result of {len(buildings)} buildings is {end_final_result - begin_final_result:.2f} Seconds.")

        saving_time = self.save_results_of_all_buildings_in_csv_parallel_using_thread_executor(
            buildings, result)

        logging.info(
            f"Time of saving hours results of {len(buildings)} buildings is {saving_time:.2f} Seconds.")
        logging.warning(
            f"Total time to simulate {len(buildings)} buildings and save hourly and final results is {simulation_time + saving_time + unpack_time:.2f} Seconds.")
        logging.info(f'-----------------------------End simulation using process----------------------------')
        logging.info("-" * 90)
        logging.info("-" * 90)

    def unpack_results(self, results):
        begin_unpack_time = time.time()
        result, result_output = zip(*results)
        end_unpack_time = time.time()
        return end_unpack_time - begin_unpack_time, result, result_output

    def save_results_of_all_buildings_in_csv_parallel_using_thread_executor(self, buildings, result):
        begin_saving_time = time.time()

        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = [
                executor.submit(self.datasource.result_of_all_hours_to_csv, result[index], building
                                ) for index, building in enumerate(buildings)]
            results = [future.result() for future in concurrent.futures.as_completed(futures)]
        end_saving_time = time.time()
        return end_saving_time - begin_saving_time

    def save_results_of_all_buildings_in_excel_parallel_using_thread_executor(self, buildings, result):
        begin_saving_time = time.time()

        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = [
                executor.submit(self.datasource.result_of_all_hours_to_excel, result[index], building
                                ) for index, building in enumerate(buildings)]
            results = [future.result() for future in concurrent.futures.as_completed(futures)]
        end_saving_time = time.time()
        return begin_saving_time, end_saving_time

    def print_time(self, begin, buildings, end, saving_time, unpack_time):
        logging.info(
            f"Time of saving hours results of {len(buildings)} buildings is {saving_time:.2f} Seconds.")
        logging.warning(
            f"Total time to simulate {len(buildings)} buildings and save hourly and final results is {end - begin + saving_time + unpack_time:.2f} Seconds.")
        logging.info(f'----------------------End simulation using process -----------------------')

    def simulate_all_buildings_parallel_using_process_executor(self, buildings, generate_data, weather_period):
        begin_simulation_time = time.time()

        with concurrent.futures.ProcessPoolExecutor() as executor:
            futures = [
                executor.submit(self.calculate_result_of_all_buildings, generate_data, weather_period, index,
                                ) for index, building in enumerate(buildings)]
            results = [future.result() for future in concurrent.futures.as_completed(futures)]
        end_simulation_time = time.time()
        return end_simulation_time - begin_simulation_time, results

    def run_simulation(self, generate_data, weather_period, index, max_concurrent):
        semaphore = threading.BoundedSemaphore(max_concurrent)
        with semaphore:
            return self.calculate_result_of_all_buildings(generate_data, weather_period, index)

    def parallel_process_max_concurrent(self, generate_data: GenerateData, weather_period, max_concurrent):
        buildings = generate_data.all_buildings
        begin = time.time()

        logging.info(f'------------Simulation using process with max_concurrent {max_concurrent}---------------')

        with concurrent.futures.ProcessPoolExecutor() as executor:
            futures = [
                executor.submit(self.run_simulation, generate_data, weather_period, index, max_concurrent) for
                index, building in enumerate(buildings)
            ]

            results = [future.result() for future in concurrent.futures.as_completed(futures)]

        end = time.time()
        logging.info(f"Parallel Process Calculation time is {end - begin:.2f} Seconds.")

        unpack_time, result, result_output = self.unpack_results(results)

        begin_final_result = time.time()
        self.datasource.build_all_results_of_all_buildings(result_output)
        end_final_result = time.time()
        logging.info(
            f"Time of saving the final result of {len(buildings)} buildings is {end_final_result - begin_final_result:.2f} Seconds.")

        saving_time = self.save_results_of_all_buildings_in_csv_parallel_using_thread_executor(
            buildings, result)

        self.print_time(begin, buildings, end, saving_time, unpack_time)

    def multi(self, generate_data: GenerateData, weather_data: str):
        logging.info("-" * 90)
        logging.info("-" * 90)
        current_function_name = inspect.stack()[0][3]
        logging.info(f'-----------Simulation using the method {current_function_name}-----------')
        buildings = generate_data.all_buildings
        with multiprocessing.Pool() as pool:
            results = []
            begin = time.time()

            for index, building in enumerate(buildings):
                result = pool.apply_async(self.calculate_result_of_all_buildings, (generate_data, weather_data, index))
                results.append(result)

            pool.close()
            pool.join()

            results = [result.get() for result in results]
            end = time.time()
            logging.info(f"Parallel Process Calculation time is {time.time() - begin:.2f} Seconds.")

            unpack_time, result, result_output = self.unpack_results(results)

            begin_final_result = time.time()
            self.datasource.build_all_results_of_all_buildings(result_output)
            end_final_result = time.time()
            logging.info(
                f"Time of saving the final result of {len(buildings)} buildings is {end_final_result - begin_final_result:.2f} Seconds.")

            saving_time = self.save_results_of_all_buildings_in_csv_parallel_using_thread_executor(
                buildings, result)

            self.print_time(begin, buildings, end, saving_time, unpack_time)

    def runtime_estimation(self, callback, *args, **kwargs):
        self.set_callback(callback)
        num_iterations = 10

        total_time = sum(timeit.repeat(lambda: self.callback(*args, **kwargs), number=1, repeat=num_iterations))

        average_time = total_time / num_iterations
        logging.info(f"Average runtime over {num_iterations} Iterations {average_time:.6f} Seconds")
